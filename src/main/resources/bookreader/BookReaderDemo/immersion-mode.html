<!DOCTYPE html>
<html>
<head>
    <title>Start in immersion mode</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- JS dependencies -->
    <script src="../BookReader/webcomponents-bundle.js"></script>
    <script src="../BookReader/jquery-3.js"></script>

    <!-- BookReader and plugins -->
    <link rel="stylesheet" href="../BookReader/BookReader.css"/>
    <script src="../BookReader/BookReader.js"></script>

    <!-- URL-changing plugin -->
    <script src="../BookReader/plugins/plugin.url.js"></script>

    <!-- Custom CSS overrides -->
    <link rel="stylesheet" href="BookReaderDemo.css"/>
    <style>
      html, body {
        height: 100%;
      }
      body.BRfullscreenActive {
        background: #000;
        overflow: hidden;
      }
      body.BRfullscreenActive #BookReader {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #BookReader .BRtoolbarSectionTitle,
      #BookReader .BRtoolbarSectionInfo,
      #BookReader .BRtoolbarSectionLogo {
        display: none !important;
      }
    
      
      /* Text overlay styles */
      .BRpagecontainer {
        position: relative;
      }
      .BRpageimage {
        position: relative;
      }
      /* Make sure the overlay is on top and interactive */
      .BRtextOverlay {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 1000 !important;
        pointer-events: auto !important;
        -webkit-user-select: text !important;
        -khtml-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
        cursor: text !important;
        mix-blend-mode: multiply; /* Makes text more readable over images */
      }
      
      /* Reset pointer-events and ensure text selection for all elements inside the overlay */
      .BRtextOverlay * {
        pointer-events: auto !important;
        -webkit-user-select: text !important;
        -khtml-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
        cursor: text !important;
      }
      .BRtextOverlay span {
        position: absolute;
        white-space: pre;
        color: rgba(0, 0, 0, 0.8); /* Make text visible */
        pointer-events: auto !important;
        -webkit-user-select: text !important;
        user-select: text !important;
        cursor: text !important;
        line-height: 1.2;
        transform-origin: 0 0;
        pointer-events: auto;
        cursor: text;
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        background: rgba(255, 255, 255, 0.7); /* Slightly more opaque for better readability */
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        margin: -1px; /* Compensate for border */
      }
      
      /* Improve text selection appearance */
      .BRtextOverlay span::selection,
      .BRtextOverlay span *::selection {
        background: rgba(0, 120, 255, 0.5) !important;
        color: #000 !important;
        text-shadow: none !important;
      }
      
      /* For Firefox */
      .BRtextOverlay span::-moz-selection,
      .BRtextOverlay span *::-moz-selection {
        background: rgba(0, 120, 255, 0.5) !important;
        color: #000 !important;
        text-shadow: none !important;
      }
    </style>
</head>
<body>
  <div id="BookReader"></div>
  <script type="text/javascript" src="BookReaderJSSimple.js"></script>
  <script type="text/javascript" src="../BookReader/plugins/plugin.text_selection.js"></script>
  <script>
    // Sample text data - in a real app, this would come from OCR data
    // Format: { pageIndex: [{ text: 'word', x: 0, y: 0, width: 100, height: 20 }, ...] }
    const textLayers = {};

    function addTextOverlay() {
      // Wait for BookReader to be initialized
      const checkBookReader = setInterval(() => {
        if (window.llgBookReader) {
          clearInterval(checkBookReader);
          const br = window.llgBookReader;
          
          // Initialize text selection plugin if available
          if (br.plugins && br.plugins.TextSelection) {
            br.plugins.TextSelection.attach();
          }
          
          // Override the drawLeaf function to add our text overlay
          const originalDrawLeaf = br.drawLeaf;
          br.drawLeaf = function(index, leaf) {
            // Call the original function
            const result = originalDrawLeaf.apply(this, arguments);
            
            // Get the page container and image
            const pageContainer = $(`#pagediv${index}`);
            const pageImage = $(`#page${index}`);
            
            // Skip if elements not found
            if (!pageContainer.length || !pageImage.length) return result;
            
            // Create or update text overlay
            updateTextOverlay(index, pageContainer, pageImage);
            
            return result;
          };
          
          // Update text positions on zoom/pan
          br.bind('updateView', function() {
            for (let i = 0; i < br.getNumLeafs(); i++) {
              const pageContainer = $(`#pagediv${i}`);
              const pageImage = $(`#page${i}`);
              if (pageContainer.length && pageImage.length) {
                updateTextOverlay(i, pageContainer, pageImage);
              }
            }
          });
          
          // Handle text selection and double-click to select word
          $(document).on('dblclick', '.BRtextOverlay', function(e) {
            const selection = window.getSelection();
            if (selection.toString().length > 0) {
              // Text is already selected, don't interfere
              return;
            }
            
            // Get the word under cursor on double-click
            const range = document.caretRangeFromPoint(e.clientX, e.clientY);
            if (range) {
              range.expand('word');
              selection.removeAllRanges();
              selection.addRange(range);
              console.log('Word selected:', selection.toString());
            }
          });
          
          // Handle text selection on mouseup
          $(document).on('mouseup', '.BRtextOverlay', function(e) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            if (selectedText.length > 0) {
              console.log('Text selected:', selectedText);
              // You can add additional selection handling here
            }
          });
          // Refresh the display to apply our changes
          window.llgBookReader.updateIndex(window.llgBookReader.currentIndex());
        }
      }, 100);
    }
    
    // Function to update text overlay for a page
    function updateTextOverlay(pageIndex, container, image) {
      console.log('=== UPDATE TEXT OVERLAY CALLED ===');
      console.log('Page index:', pageIndex);
      console.log('Container:', container);
      console.log('Image:', image);
      console.log(`[DEBUG] Updating text overlay for page ${pageIndex}`, { 
        containerExists: !!container,
        containerLength: container ? container.length : 0,
        imageExists: !!image,
        imageLength: image ? image.length : 0,
        imageSrc: image ? image.attr('src') : null
      });
      
      try {
        // Remove existing overlay if it exists
        const existingOverlay = $(`.BRtextOverlay[data-page="${pageIndex}"]`);
        if (existingOverlay.length) {
          console.log(`[DEBUG] Removing existing overlay for page ${pageIndex}`);
          existingOverlay.remove();
        }
        
        // Make sure we have valid elements
        if (!container || !container.length || !image || !image.length) {
          console.warn(`[WARN] Invalid container or image for page ${pageIndex}`, {
            container: container ? 'exists' : 'missing',
            image: image ? 'exists' : 'missing'
          });
          return;
        }
        
        // Get page dimensions and position
        const pageWidth = image.width();
        const pageHeight = image.height();
        
        console.log(`[DEBUG] Page ${pageIndex} dimensions: ${pageWidth}x${pageHeight}`);
        
        if (!pageWidth || !pageHeight) {
          console.warn(`[WARN] Invalid dimensions for page ${pageIndex}: ${pageWidth}x${pageHeight}`);
          // Try again in case the image hasn't loaded yet
          if (image[0].complete === false) {
            console.log(`[DEBUG] Image not loaded yet, adding load handler`);
            image.one('load', () => {
              console.log(`[DEBUG] Image loaded, retrying overlay for page ${pageIndex}`);
              updateTextOverlay(pageIndex, container, image);
            });
          } else {
            console.warn(`[WARN] Image marked as complete but has no dimensions`);
          }
          return;
        }
        
        console.log(`Page ${pageIndex} dimensions: ${pageWidth}x${pageHeight}`);
        
        // Create overlay container with a unique ID for debugging
        const overlayId = 'textOverlay_' + pageIndex;
        const overlay = $('<div>', {
          id: overlayId,
          'class': 'BRtextOverlay',
          'data-page': pageIndex,
          css: {
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            zIndex: 2147483647, // Max z-index
            pointerEvents: 'auto'
          }
        });
        
        // Add a debug message
        console.log('Creating overlay with ID:', overlayId);
        
        // Position overlay absolutely within the container
        overlay.css({
          position: 'absolute',
          left: '0',
          top: '0',
          width: '100%',
          height: '100%',
          'z-index': '1000',
          'pointer-events': 'none',
          'overflow': 'visible',
          'background-color': 'rgba(255, 0, 0, 0.1)' // Debug: Add semi-transparent red background
        });
        
        console.log(`[DEBUG] Adding overlay to container`, {
          containerId: container.attr('id'),
          containerClass: container.attr('class')
        });
        
        // Ensure container has relative positioning
        container.css('position', 'relative');
        
        // Add overlay to the container with a bright border for debugging
        overlay.css('border', '2px solid #00ff00');
        container.append(overlay);
        console.log('Overlay added to container:', overlay);
        
        // Force a reflow and log the computed styles
        setTimeout(() => {
          const style = window.getComputedStyle(overlay[0]);
          console.log('Overlay styles after append:', {
            display: style.display,
            visibility: style.visibility,
            opacity: style.opacity,
            position: style.position,
            zIndex: style.zIndex,
            width: style.width,
            height: style.height
          });
        }, 100);
        
        console.log(`[DEBUG] Overlay added to DOM`, {
          parent: overlay.parent().attr('id') || overlay.parent().attr('class'),
          overlayInDOM: document.body.contains(overlay[0])
        });
        
        // Get or generate text data for this page
        if (!textLayers[pageIndex]) {
          textLayers[pageIndex] = generateSampleTextData(pageIndex, pageWidth, pageHeight);
        }
        
        // Add text spans to overlay
        const textData = textLayers[pageIndex] || [];
        console.log(`Adding ${textData.length} text elements to page ${pageIndex}`);
        
        textData.forEach((word, i) => {
          try {
            const span = $(`<span>${word.text}</span>`);
            const fontSize = word.fontSize || word.height * 0.8;
            
            // Create span with all necessary styles
            const spanStyle = {
              position: 'absolute',
              left: (word.x || 0) + 'px',
              top: (word.y || 0) + 'px',
              width: (word.width || 200) + 'px',
              height: (word.height || 30) + 'px',
              fontSize: fontSize + 'px',
              lineHeight: (word.height || 30) + 'px',
              transform: `scale(${word.scaleX || 1}, ${word.scaleY || 1})`,
              transformOrigin: '0 0',
              color: word.color || 'rgba(0, 0, 0, 0.8)',
              backgroundColor: 'rgba(255, 255, 255, 0.7)',
              padding: '2px 4px',
              borderRadius: '3px',
              border: '1px solid rgba(0, 0, 0, 0.2)',
              pointerEvents: 'auto',
              WebkitUserSelect: 'text',
              MozUserSelect: 'text',
              msUserSelect: 'text',
              userSelect: 'text',
              cursor: 'text',
              zIndex: 2147483647,
              boxSizing: 'border-box',
              // Additional properties for better selection
              WebkitTouchCallout: 'default',
              WebkitUserDrag: 'none',
              WebkitTapHighlightColor: 'transparent'
            };
            
            // Apply styles with !important using direct DOM manipulation
            const spanElement = document.createElement('span');
            spanElement.setAttribute('unselectable', 'off');
            
            // Apply styles directly to the element
            for (const [prop, value] of Object.entries(spanStyle)) {
              // Convert camelCase to kebab-case for CSS properties
              const cssProp = prop.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
              spanElement.style.setProperty(cssProp, value, 'important');
            }
            
            // Set text content
            spanElement.textContent = word.text;
            
            // Add to overlay
            overlay[0].appendChild(spanElement);
            
            // Log for debugging
            console.log('Added text span:', {
              text: word.text,
              x: word.x,
              y: word.y,
              element: spanElement
            });
            
            overlay.append(span);
            console.log(`Added text: "${word.text}" at (${word.x}, ${word.y})`);
          } catch (e) {
            console.error(`Error adding text span ${i}:`, e);
          }
        });
        
        // Force a redraw
        overlay.hide().show(0);
        
      } catch (e) {
        console.error('Error in updateTextOverlay:', e);
      }
    }
    
    // Generate sample text data for demonstration
    function generateSampleTextData(pageIndex, pageWidth, pageHeight) {
      // Use fixed positions for the sample text
      const words = [
        { text: 'Sample', x: 100, y: 100, width: 120, height: 30 },
        { text: 'Text', x: 230, y: 100, width: 80, height: 30 },
        { text: 'Overlay', x: 320, y: 100, width: 120, height: 30 },
        { text: 'Page ' + (pageIndex + 1), x: 100, y: 150, width: 200, height: 40, fontSize: 24 },
        { text: 'You can select this text', x: 100, y: 200, width: 300, height: 30 },
        { text: 'Try highlighting and copying!', x: 100, y: 250, width: 300, height: 30, color: '#0066cc' },
        { text: 'This is a test overlay', x: 100, y: 300, width: 250, height: 30, color: '#cc0000' },
        { text: 'Hello from BookReader!', x: 100, y: 350, width: 300, height: 30, fontSize: 20, color: '#008800' }
      ];
      
      // Add some debug text to help with positioning
      words.push({
        text: `Page Size: ${pageWidth}x${pageHeight}`, 
        x: 20, 
        y: 20, 
        width: 200, 
        height: 20,
        fontSize: 14,
        color: '#666666'
      });
      
      return words;
    }
    
    // Function to initialize BookReader with text overlay
    function initializeBookReader(options = {}) {
      console.log('[DEBUG] Initializing BookReader with options:', options);
      
      const defaultOptions = {
        startFullscreen: true,
        autoFit: true,
        ready: function() {
          console.log('[DEBUG] BookReader ready, initializing text overlay...');
          
          // Store reference to BookReader instance
          window.llgBookReader = this;
          console.log('[DEBUG] Stored BookReader instance in window.llgBookReader');
          
          // Add overlay update to the page flip handler
          const originalUpdateIndex = this.updateIndex;
          this.updateIndex = function(index) {
            console.log(`[DEBUG] Updating to page index: ${index}`);
            originalUpdateIndex.call(this, index);
            
            // Small delay to ensure DOM is updated
            setTimeout(() => {
              console.log(`[DEBUG] Checking page ${index} after update`);
              const currentView = this._models.data[this.currentIndex()];
              console.log(`[DEBUG] Current view:`, currentView);
              
              if (currentView) {
                const pageContainer = $(`#pagediv${this.currentIndex()}`);
                const pageImage = pageContainer.find('img');
                
                console.log(`[DEBUG] Page container found:`, {
                  containerExists: pageContainer.length > 0,
                  imageExists: pageImage.length > 0,
                  containerId: pageContainer.attr('id'),
                  imageSrc: pageImage.attr('src')
                });
                
                if (pageContainer.length && pageImage.length) {
                  console.log(`[DEBUG] Calling updateTextOverlay for page ${this.currentIndex()}`);
                  updateTextOverlay(this.currentIndex(), pageContainer, pageImage);
                  
                  // Debug: Log the container's HTML for inspection
                  console.log(`[DEBUG] Container HTML:`, pageContainer.html());
                } else {
                  console.warn(`[WARN] Could not find page container or image for page ${this.currentIndex()}`);
                }
              }
            }, 300); // Increased delay to ensure DOM updates
          };
          
          // Initial overlay setup
          console.log('[DEBUG] Calling initial addTextOverlay');
          addTextOverlay();
          
          // Force an initial update of the view
          if (this.updateIndex) {
            console.log('[DEBUG] Forcing initial updateIndex call');
            this.updateIndex(this.currentIndex());
          } else {
            console.error('[ERROR] updateIndex is not defined on BookReader instance');
          }
        },
        // Add error handling
        error: function(error) {
          console.error('BookReader error:', error);
        }
      };
      
      // Merge default options with provided options
      const finalOptions = { ...defaultOptions, ...options };
      
      // Initialize BookReader
      instantiateBookReader('#BookReader', finalOptions);
    }
    
    // Start the BookReader initialization
    console.log('Starting BookReader initialization...');
    
    // Wait for everything to be ready
    $(document).ready(function() {
      console.log('Document ready, initializing BookReader...');
      
      // Initialize BookReader with options
      try {
        const br = initializeBookReader({
          reduce: 1,
          // Force single page mode to make it easier to target elements
          defaults: 'single',
          // Disable some features that might interfere
          enableSearch: false,
          enablePageTurner: false,
          // Make sure we can access the instance
          ui: 'full',
          // Add a callback when the page changes
          pageChangeCallback: function(index) {
            console.log('Page changed to:', index);
            // Small delay to ensure DOM is updated
            setTimeout(function() {
              const pageContainer = $('#BookReader').find('.BRpagecontainer').first();
              const pageImage = pageContainer.find('img').first();
              if (pageContainer.length && pageImage.length) {
                console.log('Found page container and image, updating overlay...');
                updateTextOverlay(index, pageContainer, pageImage);
              } else {
                console.warn('Could not find page container or image');
              }
            }, 100);
          }
        });
        
        // Store the BookReader instance globally
        window.llgBookReader = br;
        
      } catch (e) {
        console.error('Error initializing BookReader:', e);
      }
    });
  </script>
</body>
</html>
