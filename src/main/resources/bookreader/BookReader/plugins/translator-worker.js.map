{"version":3,"file":"plugins/translator-worker.js","mappings":"yBAKA,IAAIA,EAAS,CAAC,EAMM,oBAATC,OACPC,OAAOF,OAASA,EAEhBE,OAAOD,KAAO,IAAI,MAEd,GAEA,WAAAE,GACI,MAAM,WAACC,GAAcC,QAAkC,uBACvDC,MAAK,EAAQF,CACjB,CAOA,gBAAAG,CAAiBC,EAAWC,GACxBH,MAAK,EAAMI,GAAGF,GAAYG,GAASF,EAAS,CAACE,UACjD,CAMA,WAAAC,CAAYC,GACRP,MAAK,EAAMM,YAAYC,EAC3B,CAKA,aAAAC,IAAiBC,GACb,MAAM,aAACC,GAAgBX,QAAkC,YACnD,KAACY,GAAQZ,QAAkC,aACjD,IAAK,IAAIa,KAAYH,EAAS,CAC1B,MAAMI,EAASH,EAAaC,EAAKG,UAAWF,GAAW,CAACG,SAAU,UAClEC,KAAKC,KAAKrB,OAAQiB,EACtB,CACJ,CASA,WAAMK,CAAMC,EAAKC,GACb,GAAqB,UAAjBD,EAAIE,SAAsB,CAC1B,MAAM,SAACC,GAAYvB,QAAkC,oBAC/CwB,QAAeD,EAASH,EAAIP,UAC5BY,EAAO,IAAIC,KAAK,CAACF,IACvB,OAAO,IAAIG,SAASF,EAAM,CACtBG,OAAQ,IACRC,WAAY,KACZC,QAAS,CACL,eAAgB,mBAChB,iBAAkBL,EAAKM,KAAKC,aAGxC,CAEA,aAAab,MAAMC,EAAKC,EAC5B,CAEA,YAAIY,GACA,OAAO,IAAIC,IAAI,UAAUC,aAC7B,IAIR,MAAMC,EAQF,YAAOC,CAAMC,GACT,MAAMC,EAAM,CAAC,EAsBb,OApBAD,EAAKE,MAAM,MAAMC,QAAO,CAACC,EAAKC,EAAMC,KAChC,IAAIC,EACJ,GAAIA,EAAQF,EAAKE,MAAM,kBACdC,MAAMC,QAAQR,EAAIG,MACnBH,EAAIG,GAAOH,EAAIG,GAAKM,OAAS,CAACT,EAAIG,IAAQ,IAC9CH,EAAIG,GAAKO,KAAKJ,EAAM,GAAGG,aAEtB,GAAIH,EAAQF,EAAKE,MAAM,6CACxBH,EAAMG,EAAM,GACZN,EAAIG,GAAOG,EAAM,GAAGG,YAEnB,GAAKL,EAAKK,OAIX,MAAME,MAAM,wBAAwBN,EAAE,OAAOD,MAEjD,OAAOD,CAAG,GACX,MAEIH,CACX,CAQA,gBAAOY,CAAU7C,GACb,OAAO8C,OAAOC,QAAQ/C,GAAMmC,QAAO,CAACa,GAAMZ,EAAKa,MAC3C,IAAIC,EAAS,GAQb,OANIA,EADAV,MAAMC,QAAQQ,GACLA,EAAME,KAAIC,GAAO,SAASA,MAAO9C,KAAK,KACzB,iBAAV2C,GAAuC,kBAAVA,GAAuBA,EAAMV,MAAM,iBACnE,GAAGU,KAIT,GAAGD,IAAMZ,MAAQc,KAAU,GACnC,GACP,EAOJ,MAAMG,EAMFC,sCAAwC,CACpC,eAAkB,uBAClB,eAAkB,uBAClB,+BAAkC,qCAClC,yCAA4C,8CAC5C,kBAAqB,0BACrB,2BAA8B,iCAC9B,yBAA4B,gCAOhCA,uBAAyB,aAMzB,WAAA9D,CAAYuB,GAAU,CAiBtB,gBAAMwC,CAAWxC,GACbpB,KAAKoB,QAAUA,GAAW,CAAC,EAC3BpB,KAAK6D,OAAS,IAAIC,IAClB9D,KAAK+D,aAAe/D,KAAKgE,aACzBhE,KAAKiE,cAAgBjE,KAAKkE,wBAC9B,CAUA,iBAAAC,CAAkBC,GACd,IAAKC,YAAwB,WAEzB,OADAC,QAAQC,KAAK,0EACNvE,KAAKwE,oBAAoBJ,GAGpC,MAAMK,EAAW,IAAIJ,YAAYK,SAASL,YAAwB,aAAK,CACnE,GAAI,CAACM,OAAQP,EAAU,IAAU,UAGrC,OAAKvB,MAAM+B,KAAKzB,OAAO0B,KAAKnB,EAAyBoB,iCAAiCC,OAAMC,GAAOP,EAASQ,QAAQD,KAK7GP,EAASQ,SAJZX,QAAQC,KAAK,4EACNvE,KAAKwE,oBAAoBJ,GAIxC,CASA,mBAAAI,CAAoBJ,GAChB,MAAMc,EAAU/B,OAAOC,QAAQM,EAAyBoB,gCAAgCtB,KAAI,EAAEf,EAAK0C,KACxF,CAAC1C,EAAK,IAAI2C,IAAS1F,EAAY,IAAEyF,MAASC,MAGrD,OAAOjC,OAAOkC,YAAYH,EAC9B,CAQA,UAAAlB,GACI,OAAO,IAAIsB,SAAQC,MAAOC,EAASC,KAC/B,IACI,MAAMC,QAAiB/F,KAAKuB,MAAM,IAAIe,IAAI,oCAAqCtC,KAAKqC,WAEpFmB,OAAOwC,OAAOjG,EAAQ,CAClBkG,gBAAiB,CAACxB,EAAMyB,KACpB,IACIxB,YAAYyB,qBAAqBJ,EAAU,IACpCtB,EACH,UAAapE,KAAKoB,QAAQ2E,iBACpB/F,KAAKmE,kBAAkBC,GACvBpE,KAAKwE,oBAAoBJ,KAChC4B,MAAK,EAAEvB,cAAcoB,EAAOpB,KAAWwB,MAAMR,EACpD,CAAE,MAAOS,GACLT,EAAOS,EACX,CACA,MAAO,CAAC,CAAC,EAEbC,qBAAsB,KAClBX,EAAQ9F,EAAO,IAKvBC,KAAKD,OAASA,EACdC,KAAKa,cAAc,gCACvB,CAAE,MAAO0F,GACLT,EAAOS,EACX,IAER,CAMA,sBAAAhC,GACI,OAAO,IAAIlE,KAAK+D,OAAOqC,gBAAgB,CACnCC,UAAWC,KAAKC,IAAIvG,KAAKoB,QAAQiF,WAAa,EAAG,IAEzD,CAQA,mBAAAG,EAAoB,KAAC5B,EAAI,GAAC6B,IACtB,MAAMhE,EAAMiE,KAAKxD,UAAU,CAAC0B,OAAK6B,OACjC,OAAOzG,KAAK6D,OAAO8C,IAAIlE,EAC3B,CAiBA,oBAAAmE,EAAqB,KAAChC,EAAI,GAAE6B,GAAKI,GAE7B,MAAMC,EAAeD,EAAQE,OAAOC,QAAO,CAACC,EAAOC,EAAOH,KAC9CA,EAAOI,MAAM,EAAGD,GAAOE,SAASH,MAGrCI,EAAaC,EAAiBC,KAAiBC,GAAe,CACjExH,KAAKyH,+BAA+BZ,EAAQa,MAAO,KACnD1H,KAAKyH,+BAA+BZ,EAAQc,UAAW,IACvDd,EAAQU,aACFvH,KAAKyH,+BAA+BZ,EAAQU,aAAc,IAC1D,QACHT,EAAatD,KAAIyD,GAASjH,KAAKyH,+BAA+BR,EAAO,OAGtEF,EAAS,IAAI/G,KAAK+D,OAAO6D,kBAC/BJ,EAAYK,SAAQZ,GAASF,EAAOe,UAAUb,KAG9C,IAAIc,EAAc5F,EAAKC,MAAM,yMASzByE,EAAQmB,QACR7E,OAAOwC,OAAOoC,EAAalB,EAAQmB,QAGD,SAAlCD,EAAY,oBACZA,EAAY,kBAAoB,gBAGpC5E,OAAOwC,OAAOoC,EAAa5F,EAAKC,MAAM,iPAUtC,MAAMK,EAAMiE,KAAKxD,UAAU,CAAC0B,OAAK6B,OACjCzG,KAAK6D,OAAOoE,IAAIxF,EAAK,IAAIzC,KAAK+D,OAAOmE,iBAAiB/F,EAAKe,UAAU6E,GAAcV,EAAaC,EAAiBP,EAAQQ,GAC7H,CAOA,oBAAAY,EAAqB,KAACvD,EAAI,GAAE6B,IACxB,MAAMhE,EAAMiE,KAAKxD,UAAU,CAAC0B,OAAK6B,OAEjC,IAAKzG,KAAK6D,OAAO8C,IAAIlE,GACjB,OAEJ,MAAMiF,EAAQ1H,KAAK6D,OAAOuE,IAAI3F,GAC9BzC,KAAK6D,OAAOwE,OAAO5F,GAEnBiF,EAAMW,QACV,CASA,8BAAAZ,CAA+BlG,EAAQ+G,GACnC,MAAMC,EAAQ,IAAIC,UAAUjH,GACtBoD,EAAS,IAAI3E,KAAK+D,OAAO0E,cAAcF,EAAMG,WAAYJ,GAE/D,OADA3D,EAAOgE,mBAAmBV,IAAIM,GACvB5D,CACX,CASA,SAAAiE,EAAU,OAAC/E,EAAM,MAAEgF,IAEf,IAAIC,EAAQ,IAAI9I,KAAK+D,OAAOgF,aAC5BF,EAAMhB,SAAQ,EAAEmB,UAAUF,EAAMhB,UAAUkB,KAG1C,IAAI5H,EAAU,IAAIpB,KAAK+D,OAAOkF,sBAC9BJ,EAAMhB,SAAQ,EAAEqB,OAAMC,mBAAmB/H,EAAQ0G,UAAU,CAACsB,WAAW,EAAOF,OAAMC,oBAGpF,MAAME,EAAoBxF,EAAOL,KAAI,EAAEoB,OAAK6B,SACxC,MAAMhE,EAAMiE,KAAKxD,UAAU,CAAC0B,OAAK6B,OACjC,OAAOzG,KAAK6D,OAAOuE,IAAI3F,EAAI,IAIzB6G,EAAYzF,EAAO0F,OAAS,EAC5BvJ,KAAKiE,QAAQuF,wBAAwBH,EAAmBP,EAAO1H,GAC/DpB,KAAKiE,QAAQ2E,aAAaS,EAAmBP,EAAO1H,GAE1D0H,EAAMT,SACNjH,EAAQiH,SAKR,MAAMoB,EAAeZ,EAAMrF,KAAI,CAACkG,EAAG/G,KAAM,CACrCgH,OAAQ,CACJX,KAAMM,EAAUlB,IAAIzF,GAAGiH,yBAM/B,OAFAN,EAAUjB,SAEHoB,CACX,EAaJ,SAASI,EAAWC,GAChB,MAAO,CACH3E,KAAM2E,EAAM3E,KACZ5E,QAASuJ,EAAMvJ,QACfwJ,MAAOD,EAAMC,MAErB,CAIA,MAAMC,EAAS,IAAItG,EAEnB/D,KAAKM,iBAAiB,WAAWsF,gBAAgBlF,MAAM,GAAC4J,EAAE,KAAE9E,EAAI,KAAEC,KACzD6E,GACD3F,QAAQwF,MAAM,8BAA+BI,UAAU,IAE3D,IACI,GAA4B,mBAAjBF,EAAO7E,GACd,MAAMgF,UAAU,UAAUhF,wBAI9B,MAAMiF,QAAe9E,QAAQE,QAAQ6E,QAAQC,MAAMN,EAAO7E,GAAO6E,EAAQ5E,IACzEzF,KAAKW,YAAY,CAAC2J,KAAIG,UAC1B,CAAE,MAAON,GACLnK,KAAKW,YAAY,CACb2J,KACAH,MAAOD,EAAWC,IAE1B,CACJ,G","sources":["webpack://@internetarchive/bookreader/./node_modules/@internetarchive/bergamot-translator/worker/translator-worker.js"],"sourcesContent":["/**\n * Wrapper around the dirty bits of Bergamot's WASM bindings.\n */\n\n// Global because importScripts is global.\nvar Module = {};\n\n/**\n * node.js compatibility: Fake GlobalWorkerScope that emulates being inside a\n * WebWorker\n */\nif (typeof self === 'undefined') {\n    global.Module = Module;\n\n    global.self = new class GlobalWorkerScope {\n        /** @type {import(\"node:worker_threads\").MessagePort} */\n        #port;\n\n        constructor() {\n            const {parentPort} = require(/* webpackIgnore: true */ 'node:worker_threads');\n            this.#port = parentPort;\n        }\n\n        /**\n         * Add event listener to listen for messages posted to the worker.\n         * @param {string} eventName\n         * @param {(object)} callback\n         */\n        addEventListener(eventName, callback) {\n            this.#port.on(eventName, (data) => callback({data}));\n        }\n\n        /**\n         * Post message outside, to the owner of the Worker.\n         * @param {any} message\n         */\n        postMessage(message) {\n            this.#port.postMessage(message);\n        }\n\n        /**\n         * @param {...string} scripts - Paths to scripts to import in that order\n         */\n        importScripts(...scripts) {\n            const {readFileSync} = require(/* webpackIgnore: true */ 'node:fs');\n            const {join} = require(/* webpackIgnore: true */ 'node:path');\n            for (let pathname of scripts) {\n                const script = readFileSync(join(__dirname, pathname), {encoding: 'utf-8'});\n                eval.call(global, script);\n            }\n        }\n\n        /**\n         * Adds support for local file urls. Assumes anything that doesn't start\n         * with \"http\" to be a local path.\n         * @param {string} url - path or url\n         * @param {object?} options - See `fetch()` options\n         * @return {Promise<Response>}\n         */\n        async fetch(url, options) {\n            if (url.protocol === 'file:') {\n                const {readFile} = require(/* webpackIgnore: true */ 'node:fs/promises');\n                const buffer = await readFile(url.pathname);\n                const blob = new Blob([buffer]);\n                return new Response(blob, {\n                    status: 200,\n                    statusText: 'OK',\n                    headers: {\n                        'Content-Type': 'application/wasm',\n                        'Content-Length': blob.size.toString()\n                    }\n                });\n            }\n\n            return await fetch(url, options);\n        }\n\n        get location() {\n            return new URL(`file://${__filename}`);\n        }\n    }\n}\n\nclass YAML {\n    /**\n     * Parses YAML into dictionary. Does not interpret types, all values are a\n     * string or a list of strings. No support for objects other than the top\n     * level.\n     * @param {string} yaml\n     * @return {{[string]: string | string[]}}\n     */\n    static parse(yaml) {\n        const out = {};\n\n        yaml.split('\\n').reduce((key, line, i) => {\n            let match;\n            if (match = line.match(/^\\s*-\\s+(.+?)$/)) {\n                if (!Array.isArray(out[key]))\n                    out[key] = out[key].trim() ? [out[key]] : [];\n                out[key].push(match[1].trim());\n            }\n            else if (match = line.match(/^\\s*([A-Za-z0-9_][A-Za-z0-9_-]*):\\s*(.*)$/)) {\n                key = match[1];\n                out[key] = match[2].trim();\n            }\n            else if (!line.trim()) {\n                // whitespace, ignore\n            }\n            else {\n                throw Error(`Could not parse line ${i+1}: \"${line}\"`);\n            }\n            return key;\n        }, null);\n\n        return out;\n    }\n\n    /**\n     * Turns an object into a YAML string. No support for objects, only simple\n     * types and lists of simple types.\n     * @param {{[string]: string | number | boolean | string[]}} data\n     * @return {string}\n     */\n    static stringify(data) {\n        return Object.entries(data).reduce((str, [key, value]) => {\n            let valstr = '';\n            if (Array.isArray(value))\n                valstr = value.map(val => `\\n  - ${val}`).join('');\n            else if (typeof value === 'number' || typeof value === 'boolean' || value.match(/^\\d*(\\.\\d+)?$/))\n                valstr = `${value}`;\n            else\n                valstr = `${value}`; // Quote?\n\n            return `${str}${key}: ${valstr}\\n`;\n        }, '');\n    }\n}\n\n/**\n * Wrapper around the bergamot-translator exported module that hides the need\n * of working with C++ style data structures and does model management.\n */\nclass BergamotTranslatorWorker {\n    /**\n     * Map of expected symbol -> name of fallback symbol for functions that can\n     * be swizzled for a faster implementation. Firefox Nightly makes use of\n     * this.\n     */\n    static GEMM_TO_FALLBACK_FUNCTIONS_MAP = {\n        'int8_prepare_a': 'int8PrepareAFallback',\n        'int8_prepare_b': 'int8PrepareBFallback',\n        'int8_prepare_b_from_transposed': 'int8PrepareBFromTransposedFallback',\n        'int8_prepare_b_from_quantized_transposed': 'int8PrepareBFromQuantizedTransposedFallback',\n        'int8_prepare_bias': 'int8PrepareBiasFallback',\n        'int8_multiply_and_add_bias': 'int8MultiplyAndAddBiasFallback',\n        'int8_select_columns_of_b': 'int8SelectColumnsOfBFallback'\n    };\n\n    /**\n     * Name of module exported by Firefox Nightly that exports an optimised\n     * implementation of the symbols mentioned above.\n     */\n    static NATIVE_INT_GEMM = 'mozIntGemm';\n\n    /**\n     * Empty because we can't do async constructors yet. It is the\n     * responsibility of whoever owns this WebWorker to call `initialize()`.\n     */\n    constructor(options) {}\n\n    /**\n     * Instantiates a new translation worker with optional options object.\n     * If this call succeeds, the WASM runtime is loaded and ready.\n     * \n     * Available options are:\n     *   useNativeIntGemm: {true | false} defaults to false. If true, it will\n     *                     attempt to link to the intgemm module available in\n     *                     Firefox Nightly which makes translations much faster.\n     *          cacheSize: {Number} defaults to 0 which disables translation\n     *                     cache entirely. Note that this is a theoretical\n     *                     upper bound. In practice it will use about 1/3th of\n     *                     the cache specified here. 2^14 is not a bad starting\n     *                     value.\n     * @param {{useNativeIntGemm: boolean, cacheSize: number}} options\n     */\n    async initialize(options) {\n        this.options = options || {};\n        this.models = new Map(); // Map<str,Promise<TranslationModel>>\n        this.module = await this.loadModule();\n        this.service = await this.loadTranslationService();\n    }\n\n    /**\n     * Tries to load native IntGEMM module for bergamot-translator. If that\n     * fails because it or any of the expected functions is not available, it\n     * falls back to using the naive implementations that come with the wasm\n     * binary itself through `linkFallbackIntGemm()`.\n     * @param {{env: {memory: WebAssembly.Memory}}} info\n     * @return {{[method:string]: (...any) => any}}\n     */\n    linkNativeIntGemm(info) {\n        if (!WebAssembly['mozIntGemm']) {\n            console.warn('Native gemm requested but not available, falling back to embedded gemm');\n            return this.linkFallbackIntGemm(info);\n        }\n\n        const instance = new WebAssembly.Instance(WebAssembly['mozIntGemm'](), {\n            '': {memory: info['env']['memory']}\n        });\n\n        if (!Array.from(Object.keys(BergamotTranslatorWorker.GEMM_TO_FALLBACK_FUNCTIONS_MAP)).every(fun => instance.exports[fun])) {\n            console.warn('Native gemm is missing expected functions, falling back to embedded gemm');\n            return this.linkFallbackIntGemm(info);\n        }\n\n        return instance.exports;\n    }\n\n    /**\n     * Links intgemm functions that are already available in the wasm binary,\n     * but just exports them under the name that is expected by\n     * bergamot-translator.\n     * @param {{env: {memory: WebAssembly.Memory}}} info\n     * @return {{[method:string]: (...any) => any}}\n     */\n    linkFallbackIntGemm(info) {\n        const mapping = Object.entries(BergamotTranslatorWorker.GEMM_TO_FALLBACK_FUNCTIONS_MAP).map(([key, name]) => {\n            return [key, (...args) => Module['asm'][name](...args)]\n        });\n\n        return Object.fromEntries(mapping);\n    }\n\n    /**\n     * Internal method. Reads and instantiates the WASM binary. Returns a\n     * promise for the exported Module object that contains all the classes\n     * and functions exported by bergamot-translator.\n     * @return {Promise<BergamotTranslator>}\n     */\n    loadModule() {\n        return new Promise(async (resolve, reject) => {\n            try {\n                const response = await self.fetch(new URL('./bergamot-translator-worker.wasm', self.location));\n\n                Object.assign(Module, {\n                    instantiateWasm: (info, accept) => {\n                        try {\n                            WebAssembly.instantiateStreaming(response, {\n                                ...info,\n                                'wasm_gemm': this.options.useNativeIntGemm\n                                    ? this.linkNativeIntGemm(info)\n                                    : this.linkFallbackIntGemm(info)\n                            }).then(({instance}) => accept(instance)).catch(reject);\n                        } catch (err) {\n                            reject(err);\n                        }\n                        return {};\n                    },\n                    onRuntimeInitialized: () => {\n                        resolve(Module);\n                    }\n                });\n\n                // Emscripten glue code. Webpack et al. should not mangle the `Module` property name!\n                self.Module = Module;\n                self.importScripts('bergamot-translator-worker.js');\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    /**\n     * Internal method. Instantiates a BlockingService()\n     * @return {BergamotTranslator.BlockingService}\n     */\n    loadTranslationService() {\n        return new this.module.BlockingService({\n            cacheSize: Math.max(this.options.cacheSize || 0, 0)\n        });\n    }\n\n    /**\n     * Returns whether a model has already been loaded in this worker. Marked\n     * async because the message passing interface we use expects async methods.\n     * @param {{from:string, to:string}}\n     * @return boolean\n     */ \n    hasTranslationModel({from,to}) {\n        const key = JSON.stringify({from,to});\n        return this.models.has(key);\n    }\n\n    /**\n     * Loads a translation model from a set of file buffers. After this, the\n     * model is available to translate with and `hasTranslationModel()` will\n     * return true for this pair.\n     * @param {{from:string, to:string}}\n     * @param {{\n     *   model: ArrayBuffer,\n     *   shortlist: ArrayBuffer,\n     *   vocabs: ArrayBuffer[],\n     *   qualityModel: ArrayBuffer?,\n     *   config?: {\n     *     [key:string]: string\n     *   }\n     * }} buffers\n     */ \n    loadTranslationModel({from, to}, buffers) {\n        // This because service_bindings.cpp:prepareVocabsSmartMemories :(\n        const uniqueVocabs = buffers.vocabs.filter((vocab, index, vocabs) => {\n            return !vocabs.slice(0, index).includes(vocab);\n        });\n\n        const [modelMemory, shortlistMemory, qualityModel, ...vocabMemory] = [\n            this.prepareAlignedMemoryFromBuffer(buffers.model, 256),\n            this.prepareAlignedMemoryFromBuffer(buffers.shortlist, 64),\n            buffers.qualityModel // optional quality model\n                ? this.prepareAlignedMemoryFromBuffer(buffers.qualityModel, 64)\n                : null,\n            ...uniqueVocabs.map(vocab => this.prepareAlignedMemoryFromBuffer(vocab, 64))\n        ];\n\n        const vocabs = new this.module.AlignedMemoryList();\n        vocabMemory.forEach(vocab => vocabs.push_back(vocab));\n\n        // Defaults\n        let modelConfig = YAML.parse(`\n            beam-size: 1\n            normalize: 1.0\n            word-penalty: 0\n            cpu-threads: 0\n            gemm-precision: int8shiftAlphaAll\n            skip-cost: true\n        `);\n\n        if (buffers.config)\n            Object.assign(modelConfig, buffers.config);\n\n        // WASM marian is only compiled with support for shiftedAll.\n        if (modelConfig['gemm-precision'] === 'int8')\n            modelConfig['gemm-precision'] = 'int8shiftAll';\n\n        // Override these\n        Object.assign(modelConfig, YAML.parse(`\n            alignment: soft\n            quiet: true\n            quiet-translation: true\n            max-length-break: 128\n            mini-batch-words: 1024\n            workspace: 128\n            max-length-factor: 2.0\n        `));\n\n        const key = JSON.stringify({from,to});\n        this.models.set(key, new this.module.TranslationModel(YAML.stringify(modelConfig), modelMemory, shortlistMemory, vocabs, qualityModel));\n    }\n\n    /**\n     * Frees up memory used by old translation model. Does nothing if model is\n     * already deleted.\n     * @param {{from:string, to:string}}\n     */\n    freeTranslationModel({from, to}) {\n        const key = JSON.stringify({from,to});\n        \n        if (!this.models.has(key))\n            return;\n        \n        const model = this.models.get(key);\n        this.models.delete(key);\n\n        model.delete();\n    }\n\n    /**\n     * Internal function. Copies the data from an ArrayBuffer into memory that\n     * can be used inside the WASM vm by Marian.\n     * @param {{ArrayBuffer}} buffer\n     * @param {number} alignmentSize\n     * @return {BergamotTranslator.AlignedMemory}\n     */\n    prepareAlignedMemoryFromBuffer(buffer, alignmentSize) {\n        const bytes = new Int8Array(buffer);\n        const memory = new this.module.AlignedMemory(bytes.byteLength, alignmentSize);\n        memory.getByteArrayView().set(bytes);\n        return memory;\n    }\n\n    /**\n     * Public. Does actual translation work. You have to make sure that the\n     * models necessary for translating text are already loaded before calling\n     * this method. Returns a promise with translation responses.\n     * @param {{models: {from:string, to:string}[], texts: {text: string, html: boolean}[]}}\n     * @return {Promise<{target: {text: string}}[]>}\n     */\n    translate({models, texts}) {\n        // Convert texts array into a std::vector<std::string>.\n        let input = new this.module.VectorString();\n        texts.forEach(({text}) => input.push_back(text));\n\n        // Extracts the texts[].html options into ResponseOption objects\n        let options = new this.module.VectorResponseOptions();\n        texts.forEach(({html, qualityScores}) => options.push_back({alignment: false, html, qualityScores}));\n\n        // Turn our model names into a list of TranslationModel pointers\n        const translationModels = models.map(({from,to}) => {\n            const key = JSON.stringify({from,to});\n            return this.models.get(key);\n        });\n\n        // translate the input, which is a vector<String>; the result is a vector<Response>\n        const responses = models.length > 1\n            ? this.service.translateViaPivoting(...translationModels, input, options)\n            : this.service.translate(...translationModels, input, options);\n        \n        input.delete();\n        options.delete();\n\n        // Convert the Response WASM wrappers into native JavaScript types we\n        // can send over the 'wire' (message passing) in the same format as we\n        // use in bergamot-translator.\n        const translations = texts.map((_, i) => ({\n            target: {\n                text: responses.get(i).getTranslatedText()\n            }\n        }));\n\n        responses.delete();\n\n        return translations;\n    }\n}\n\n/**\n * Because you can't put an Error object in a message. But you can post a\n * generic object!\n * @param {Error} error\n * @return {{\n *  name: string?,\n *  message: string?,\n *  stack: string?\n * }}\n */\nfunction cloneError(error) {\n    return {\n        name: error.name,\n        message: error.message,\n        stack: error.stack\n    };\n}\n\n// (Constructor doesn't really do anything, we need to call `initialize()`\n// first before using it. That happens from outside the worker.)\nconst worker = new BergamotTranslatorWorker();\n\nself.addEventListener('message', async function({data: {id, name, args}}) {\n    if (!id)\n        console.error('Received message without id', arguments[0]);\n\n    try {\n        if (typeof worker[name] !== 'function')\n            throw TypeError(`worker[${name}] is not a function`);\n\n        // Using `Promise.resolve` to await any promises that worker[name]\n        // possibly returns.\n        const result = await Promise.resolve(Reflect.apply(worker[name], worker, args));\n        self.postMessage({id, result});\n    } catch (error) {\n        self.postMessage({\n            id,\n            error: cloneError(error)\n        })\n    }\n});\n"],"names":["Module","self","global","constructor","parentPort","require","this","addEventListener","eventName","callback","on","data","postMessage","message","importScripts","scripts","readFileSync","join","pathname","script","__dirname","encoding","eval","call","fetch","url","options","protocol","readFile","buffer","blob","Blob","Response","status","statusText","headers","size","toString","location","URL","__filename","YAML","parse","yaml","out","split","reduce","key","line","i","match","Array","isArray","trim","push","Error","stringify","Object","entries","str","value","valstr","map","val","BergamotTranslatorWorker","static","initialize","models","Map","module","loadModule","service","loadTranslationService","linkNativeIntGemm","info","WebAssembly","console","warn","linkFallbackIntGemm","instance","Instance","memory","from","keys","GEMM_TO_FALLBACK_FUNCTIONS_MAP","every","fun","exports","mapping","name","args","fromEntries","Promise","async","resolve","reject","response","assign","instantiateWasm","accept","instantiateStreaming","useNativeIntGemm","then","catch","err","onRuntimeInitialized","BlockingService","cacheSize","Math","max","hasTranslationModel","to","JSON","has","loadTranslationModel","buffers","uniqueVocabs","vocabs","filter","vocab","index","slice","includes","modelMemory","shortlistMemory","qualityModel","vocabMemory","prepareAlignedMemoryFromBuffer","model","shortlist","AlignedMemoryList","forEach","push_back","modelConfig","config","set","TranslationModel","freeTranslationModel","get","delete","alignmentSize","bytes","Int8Array","AlignedMemory","byteLength","getByteArrayView","translate","texts","input","VectorString","text","VectorResponseOptions","html","qualityScores","alignment","translationModels","responses","length","translateViaPivoting","translations","_","target","getTranslatedText","cloneError","error","stack","worker","id","arguments","TypeError","result","Reflect","apply"],"sourceRoot":""}